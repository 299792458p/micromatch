## Quickstart

```js
var mm = require('micromatch');
mm(list, patterns[, options]);
```

The [main export](#micromatch) takes a list of strings and one or more glob patterns:

```js
console.log(mm(['foo', 'bar', 'qux'], ['f*', 'b*'])); // ['foo', 'bar']
```

Use [.isMatch](#ismatch) to get true/false:

```js
console.log(mm.isMatch('foo', 'f*'));  // true
```

**Switching from [minimatch](#switching-from-minimatch) and [multimatch](#switching-from-multimatch) is easy**:

* [mm()](#usage) is the same as [multimatch()][multimatch]
* [mm.match()](#match) is the same as [minimatch.match()][minimatch]
* use [mm.isMatch()](#ismatch) instead of [minimatch()][minimatch]


## Why use micromatch?

> micromatch is a [drop-in replacement][switch] for minimatch and multimatch

Micromatch is [safer][braces]{#braces-is-safe}, [faster](#benchmarks), more accurate, and supports all of the same matching features as [minimatch][] and [multimatch][].

Moreover, micromatch has:

* Better support for the Bash 4.3 specification than minimatch and multimatch
* More than 16,000 [unit tests](./test), with thousands more patterns tested (minimatch and multimatch fail many of the tests)
* Better windows support than minimatch and multimatch

### Features

* Native support for multiple glob patterns (no need for wrappers like multimatch)
* Glob pattern support (`**/*`, `a/b/*.js`, or `['a/*.js', '!b.js']`)
* [extglob][] support (`+(x|y)`, `!(a|b)`, etc)
* [POSIX character class][brackets] support (`**/[[:alpha:][:digit:]]/`)
* [brace expansion][braces] support (`a/b-{1..5}.md`, `one/{two,three}/four.md`)
* regex character classes (`a/b/baz-[1-5].js`)
* regex logical or (`a/b/(abc|xyz).js`)

You can mix and match these features to create whatever patterns you need!

**Example**

```js
mm(['a/b.js', 'a/b.md'], 'a/*.!(js)');
//=> ['a/b.md']
```

## Switching from minimatch

Use `mm.isMatch()` instead of `minimatch()`:

```js
mm.isMatch('foo', 'b*');
//=> false
```

Use `mm.match()` instead of `minimatch.match()`:

```js
mm.match(['foo', 'bar'], 'b*');
//=> 'bar'
```

## Switching from multimatch

Same signature:

```js
mm(['foo', 'bar', 'baz'], ['f*', '*z']);
//=> ['foo', 'baz']
```

## API
{%= apidocs("index.js") %}



## Options

- [options.basename](#options-basename) 
- [options.cache](#options-cache) 
- [options.dot](#options-dot) 
- [options.failglob](#options-failglob) 
- [options.ignore](#options-ignore) 
- [options.matchBase](#options-matchBase) 
- [options.nobrace](#options-nobrace) 
- [options.nocase](#options-nocase) 
- [options.nodupes](#options-nodupes) 
- [options.nonull](#options-nonull) 
- [options.nullglob](#options-nullglob) 
- [options.snapdragon](#options-snapdragon) 
- [options.unescape](#options-unescape) 
- [options.unixify](#options-unixify) 

### options.basename

Allow glob patterns without slashes to match a file path based on its basename. Same behavior as [minimatch][] option `matchBase`.

Type: `Boolean`

Default: `false`

**Example**

```js
mm(['a/b.js', 'a/c.md'], '*.js');
//=> []

mm(['a/b.js', 'a/c.md'], '*.js', {matchBase: true});
//=> ['a/b.js']
```

### options.cache

Disable regex and function memoization. 

Type: `Boolean`

Default: `undefined`


### options.dot

Match dotfiles. Same behavior as [minimatch][] option `dot`.

Type: `Boolean`

Default: `false`


### options.failglob

Similar to the `--failglob` behavior in Bash, throws an error when no matches are found.

Type: `Boolean`

Default: `undefined`


### options.ignore

String or array of glob patterns to match files to ignore.

Type: `String|Array`

Default: `undefined`


### options.matchBase

Alias for [options.basename](#options-basename).


### options.nobrace

Disable expansion of brace patterns. Same behavior as [minimatch][] option `nobrace`.

Type: `Boolean`

Default: `undefined`

See [braces][] for more information about extended brace expansion.


### options.nocase

Use a case-insensitive regex for matching files. Same behavior as [minimatch][].

Type: `Boolean`

Default: `undefined`


### options.nodupes

Remove duplicate elements from the result array.

Type: `Boolean`

Default: `undefined`

**Example**

Example of using the `unescape` and `nodupes` options together:

```js
mm.match(['a/b/c', 'a/b/c'], 'a/b/c');
//=> ['a/b/c', 'a/b/c']

mm.match(['a/b/c', 'a/b/c'], 'a/b/c', {nodupes: true});
//=> ['abc']
```

### options.nonegate

Disallow negation (`!`) patterns, and treat leading `!` as a literal character to match.

Type: `Boolean`

Default: `undefined`


### options.nonull

Alias for [options.nullglob](#options-nullglob).


### options.nullglob

If `true`, when no matches are found the actual (arrayified) glob pattern is returned instead of an empty array. Same behavior as [minimatch][] option `nonull`.

Type: `Boolean`

Default: `undefined`


### options.snapdragon

Pass your own instance of [snapdragon][], to customize parsers or compilers.

Type: `Object`

Default: `undefined`


### options.unescape

Remove backslashes from returned matches.

Type: `Boolean`

Default: `undefined`

**Example**

In this example we want to match a literal `*`:

```js
mm.match(['abc', 'a\\*c'], 'a\\*c');
//=> ['a\\*c']

mm.match(['abc', 'a\\*c'], 'a\\*c', {unescape: true});
//=> ['a*c']
```

### options.unixify

Convert path separators on returned files to posix/unix-style forward slashes.

Type: `Boolean`

Default: `true`

**Example**

```js
mm.match(['a\\b\\c'], 'a/**');
//=> ['a/b/c']

mm.match(['a\\b\\c'], {unixify: false});
//=> ['a\\b\\c']
```

## Extended globbing

Micromatch also supports extended globbing features.

### extglobs

Extended globbing, as described by the bash man page:

| **pattern** | **regex equivalent** | **description** |
| --- | --- | --- |
| `?(pattern-list)` | `(... | ...)?` | Matches zero or one occurrence of the given patterns |
| `*(pattern-list)` | `(... | ...)*` | Matches zero or more occurrences of the given patterns |
| `+(pattern-list)` | `(... | ...)+` | Matches one or more occurrences of the given patterns |
| `@(pattern-list)` | `(... | ...)` <sup>*</sup> | Matches one of the given patterns |
| `!(pattern-list)` | N/A | Matches anything except one of the given patterns |

<sup><strong>*</strong></sup> `@` isn't a RegEx character.

Powered by [extglob](https://github.com/jonschlinkert/extglob). Visit that library for the full range of options or to report extglob related issues.

See [extglob](https://github.com/jonschlinkert/extglob) for more information about extended globs.

### braces

**Expanded braces**

Braces are expanded when ``

* range expansion: `a{1..3}b/*.js` expands to: `['a1b/*.js', 'a2b/*.js', 'a3b/*.js']`
* nesting: `a{c,{d,e}}b/*.js` expands to: `['acb/*.js', 'adb/*.js', 'aeb/*.js']`

**Optimized braces (not expanded)**

By default, brace patterns work the same way regex logical `OR` operators. For example, `(a|b)` will achieve the same result as `{a,b}`. 

Visit [braces](https://github.com/jonschlinkert/braces) to ask questions and create an issue related to brace-expansion, or to see the full range of features and options related to brace expansion.

### regex character classes

Given the list: `['a.js', 'b.js', 'c.js', 'd.js', 'E.js']`:

* `[ac].js`: matches both `a` and `c`, returning `['a.js', 'c.js']`
* `[b-d].js`: matches from `b` to `d`, returning `['b.js', 'c.js', 'd.js']`
* `[b-d].js`: matches from `b` to `d`, returning `['b.js', 'c.js', 'd.js']`
* `a/[A-Z].js`: matches and uppercase letter, returning `['a/E.md']`

Learn about [regex character classes](http://www.regular-expressions.info/charclass.html).

### regex groups

Given `['a.js', 'b.js', 'c.js', 'd.js', 'E.js']`:

* `(a|c).js`: would match either `a` or `c`, returning `['a.js', 'c.js']`
* `(b|d).js`: would match either `b` or `d`, returning `['b.js', 'd.js']`
* `(b|[A-Z]).js`: would match either `b` or an uppercase letter, returning `['b.js', 'E.js']`

As with regex, parenthese can be nested, so patterns like `((a|b)|c)/b` will work. But it might be easier to achieve your goal using brace expansion.

### POSIX bracket expressions

**Example**

```js
mm.isMatch('a1', '[[:alpha:][:digit:]]');
//=> true
```

See [expand-brackets](https://github.com/jonschlinkert/expand-brackets) for more information about bracket expressions.

***

## Notes

**Bash 4.3 parity**

Whenever possible parsing behavior for patterns is based on globbing specifications in Bash 4.3, which is mostly also constistent with minimatch. Patterns that aren't described in enough detail by the Bash spec follow wildmatch spec (used by git). 

**Escaping**

Backslashes are exclusively and explicitly reserved for escaping characters in a glob pattern, even on windows. This is the convention in all globbing libs, including minimatch and node-glob, although some users are [confused about how this works](https://github.com/isaacs/node-glob/issues/212).

To be clear, _a glob pattern is not a filepath_, it's a [regular language](https://en.wikipedia.org/wiki/Regular_language) that is converted to a JavaScript regular expression. When you pass something like `path.join('foo', '*')` to micromatch, you are creating a filepath and expecting it to still work as a glob pattern. This causes problems on windows, since the node.js `path` module converts `/` to `\\` and/or uses `\\` as the path separator when joining paths. Since `\\` is an escape character in globs, on windows `path.join('foo', '*')` would result in `foo\\*`, which tells micromatch to match `*` as a literal character.

To get around this, you can either do the joining manually or find a lib on npm that does this.

## Benchmarks

### Running benchmarks

Install dev dependencies:

```bash
npm i -d && npm benchmark
```

### Latest results

As of {%= date() %} (longer bars are better):

```sh
{%= bench() %}
```


[switch]: #switch-from-minimatch
[expand]: #expand
[character-classes]: http://www.regular-expressions.info/charclass.html
[extended]: http://mywiki.wooledge.org/BashGuide/Patterns#Extended_Globs
[brackets]: https://github.com/jonschlinkert/expand-brackets
[braces]: https://github.com/jonschlinkert/braces
